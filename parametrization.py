import numpy as np
from scipy.optimize import minimize
import scipy.sparse.linalg as LA
import os
import matplotlib.pyplot as plt


def parametrization(numpy_file, save_to, neighbor_nums):
    """
    Embedding of the 3D coordinates into the 2D parametric space

    :param numpy_file: File generated by parametrization.hip in Houdini
    :param save_to: Folder where 2D points will saved
    :param neighbor_nums: List of neighbors' number. Ex. [20, 25, 30]
    :return:
    """
    # distance between point1 and point2
    def dist(pt1, pt2):
        return np.sqrt(np.sum((pt1 - pt2) * (pt1 - pt2)))

    # minimization function = Eq.1
    def min_func(w, row):
        return np.linalg.norm(D[row] - np.sum(w.reshape((-1, 1)) * D[N[row, :neighbor_num]], axis=0))

    # import points from numpy file
    D = np.load(numpy_file)
    num = D.shape[0]
    obj_name = os.path.splitext(os.path.basename(numpy_file))[0]

    # calculate N_dist - [num x num] matrix of distances
    # where N_dist[i, j] - distance between D[i] nad D[j]

    for neighbor_num in neighbor_nums:
        # neighbor_num = 20
        N_dist = np.zeros((num, num), float)

        for _y in range(num):
            for _x in range(num):
                N_dist[_y, _x] = dist(D[_y], D[_x])

        # sort distances' matrix to find indices of neighbor for every point
        N = np.argsort(N_dist, axis=1)

        # initial values of weight matrix _W
        # _W - partial matrix of W representing neighbor_num neighbor's weights
        # used to avoid constraint #2 for Eq.1
        w0 = np.ones(neighbor_num, float) / neighbor_num
        # print(' w0:', w0.shape)

        # constraint #1 for Eq.1
        constraints = [{'type': 'eq', 'fun': lambda w_row: np.sum(w_row) - 1.}]

        # evaluate _W
        _W = np.array([minimize(min_func, w0, args=(row,), method='SLSQP', constraints=constraints)['x'] for row in range(num)])
        # print '_W:', _W.shape

        # initialize and save W
        W = np.zeros((num, num), float)
        for row in range(num):
            W[row, N[row, :neighbor_num]] = _W[row]

        np.save('%s/%s_w.npy' % (save_to, obj_name), W)

        # calc M matrix = Eq.6
        id_matr = np.eye(num, num)
        a = id_matr - W
        M = np.dot(a.T, a)

        # find 2 and 3 smallest eigenvectors = Eq.7
        eigvalues, eigvectors = LA.eigs(M, 3, sigma=0)
        print('eigvectors:', eigvectors.shape)
        # print 'eigvalues:', eigvalues

        # save points parameter space coordinates
        P = eigvectors[:, 1:3].real
        np.save('%s/%s_p_%03d.npy' % (save_to, obj_name, neighbor_num), P)

def plot_pts(numpy_file):
    arr = np.load(numpy_file)
    plt.scatter(arr[:, 0], arr[:, 1])
    plt.show()
